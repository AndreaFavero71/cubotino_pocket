#!/usr/bin/python
# coding: utf-8

"""
#############################################################################################################
# Andrea Favero 11 February 2024
# 
# Script to virtually test CUBOTino_P solver, with all the possible 2x2x2 Rubik's cube status"
#
# The cube status, categorized by dept, is generated as per: https://github.com/ImportMathRepositories/2x2_Depth
# There are 3'674'160 different permutations, individually generated / analysed on the fly.
# Each permutation is sent to the Kociemba solver, that returns the optimal solution.
# The solver might return multiples solutions, having the same quantity of (humans) movements.
# (Default option) Alternative solutions generated by Cubotino, adding the D, B and L face rotations"
# Each solution is sent to the robot solver.
# The robot solver estimates the servos solving time per each solution, and fastest is returned.
# The selected robot solution is applied to a virtual manipulator with the CUBOTino movements.
# The cube status is updated after each virtual cube manipulation (Flip, Spin or Rotate).
# The final cube status, after last manipulation, is verified if resembling a solved cube.
#
#############################################################################################################
"""




#####################  setting argparser ###################################################
import argparse

# argument parser object creation
parser = argparse.ArgumentParser(description='Test all the cube status via a virtual cube manipulator')

# --no_dbl argument is added to the parser
parser.add_argument("--no_dbl", action='store_true',
                    help="Disable the cube solution with DBL faces rotations")

# --stop argument is added to the parser
parser.add_argument("-s", "--stop", type=int,
                    help="Input max number of permutation to test")

args = parser.parse_args()   # argument parsed assignement
# ##########################################################################################




############################################################################################
#####################   part to generate all the cube permutations  ########################
############################################################################################

# Takes a position and returns a list of all the permutations that arise from performing every move
def get_moves(pos):
    return [F1(pos), F3(pos), F2(pos),
            R1(pos), R3(pos), R2(pos),
            U1(pos), U3(pos), U2(pos)]


# Hard coded moves to perform on the cube.
def F1(pos): # Front Quarter Turn Clockwise
    return (pos[0] + pos[1] + pos[19] + pos[17] +
            pos[2] + pos[5] + pos[3] + pos[7] +
            pos[10] + pos[8] + pos[11] + pos[9] +
            pos[6] + pos[4] + pos[14] + pos[15] +
            pos[16] + pos[12] + pos[18] + pos[13] +
            pos[20] + pos[21] + pos[22] + pos[23])

def F3(pos): # Front Quarter Turn Counterclockwise
    return (pos[0] + pos[1] + pos[4] + pos[6] +
            pos[13] + pos[5] + pos[12] + pos[7] +
            pos[9] + pos[11] + pos[8] + pos[10] +
            pos[17] + pos[19] + pos[14] + pos[15] +
            pos[16] + pos[3] + pos[18] + pos[2] +
            pos[20] + pos[21] + pos[22] + pos[23])

def F2(pos): # Front Half Turn
    return (pos[0] + pos[1] + pos[13] + pos[12] +
            pos[19] + pos[5] + pos[17] + pos[7] +
            pos[11] + pos[10] + pos[9] + pos[8] +
            pos[3] + pos[2] + pos[14] + pos[15] +
            pos[16] + pos[6] + pos[18] + pos[4] +
            pos[20] + pos[21] + pos[22] + pos[23])

def R1(pos): # Right Quarter Turn Clockwise
    return (pos[0] + pos[9] + pos[2] + pos[11] +
            pos[6] + pos[4] + pos[7] + pos[5] +
            pos[8] + pos[13] + pos[10] + pos[15] +
            pos[12] + pos[22] + pos[14] + pos[20] +
            pos[16] + pos[17] + pos[18] + pos[19] +
            pos[3] + pos[21] + pos[1] + pos[23])

def R3(pos): # Right Quarter Turn Counterclockwise
    return (pos[0] + pos[22] + pos[2] + pos[20] +
            pos[5] + pos[7] + pos[4] + pos[6] +
            pos[8] + pos[1] + pos[10] + pos[3] +
            pos[12] + pos[9] + pos[14] + pos[11] +
            pos[16] + pos[17] + pos[18] + pos[19] +
            pos[15] + pos[21] + pos[13] + pos[23])

def R2(pos): # Right Half Turn
    return (pos[0] + pos[13] + pos[2] + pos[15] +
            pos[7] + pos[6] + pos[5] + pos[4] +
            pos[8] + pos[22] + pos[10] + pos[20] +
            pos[12] + pos[1] + pos[14] + pos[3] +
            pos[16] + pos[17] + pos[18] + pos[19] +
            pos[11] + pos[21] + pos[9] + pos[23])

def U1(pos): # Up Quarter Turn Clockwise
    return (pos[2] + pos[0] + pos[3] + pos[1] +
            pos[20] + pos[21] + pos[6] + pos[7] +
            pos[4] + pos[5] + pos[10] + pos[11] +
            pos[12] + pos[13] + pos[14] + pos[15] +
            pos[8] + pos[9] + pos[18] + pos[19] +
            pos[16] + pos[17] + pos[22] + pos[23])

def U3(pos):# Up Quarter Turn Counterclockwise
    return (pos[1] + pos[3] + pos[0] + pos[2] +
            pos[8] + pos[9] + pos[6] + pos[7] +
            pos[16] + pos[17] + pos[10] + pos[11] +
            pos[12] + pos[13] + pos[14] + pos[15] +
            pos[20] + pos[21] + pos[18] + pos[19] +
            pos[4] + pos[5] + pos[22] + pos[23])

def U2(pos): # Up Half Turn
    return (pos[3] + pos[2] + pos[1] + pos[0] +
            pos[16] + pos[17] + pos[6] + pos[7] +
            pos[20] + pos[21] + pos[10] + pos[11] +
            pos[12] + pos[13] + pos[14] + pos[15] +
            pos[4] + pos[5] + pos[18] + pos[19] +
            pos[8] + pos[9] + pos[22] + pos[23])
# ##########################################################################################




############################################################################################
######################   part relates to CUBOTino_P  #######################################
############################################################################################

def imports():
    global time, rm, servo    
    import Cubotino_P_moves as rm        # custom library, traslates the cuber solution string in robot movements string
    import Cubotino_P_servos as servo    # custom library for the servos control
    import time





def clear_terminal():
    """ Clears the terminal and positions the cursors on top left; Still possible to scroll up in case of need"""
    print("\x1b[H\x1b[2J")               # escape sequence





def introduction():
    row = "#"*95                         # string of characters used as separator
    print(row)                           # separator is printed to the terminal
    print(" Script to virtually test CUBOTino_P solver, with all the possible 2x2x2 Rubik's cube status")
    print(" The cube status, categorized by dept, is generated as per:")
    print(" https://github.com/ImportMathRepositories/2x2_Depth")
    print(" There are 3'674'160 different permutations, individually generated / analysed on the fly.")
    print(" Each permutation is sent to the Kociemba solver, that returns the optimal solution.")
    print(" The solver might return multiples solutions, having the same quantity of (humans) movements.")
    print(" (opt.) Alternative solutions are generated by Cubotino, adding the D, B and L face rotations.")
    print(" Each solution is sent to the robot solver.")
    print(" The robot solver estimates the servos solving time per each solution, and fastest is returned.")
    print(" The selected robot solution is applied to a virtual manipulator with the CUBOTino movements.")
    print(" The cube status is updated after each virtual cube manipulation (Flip, Spin or Rotate).")
    print(" The final cube status, after last manipulation, is verified if resembling a solved cube.")
    print(" The script has a couple of argument, type --help to check")
    print(row,"\n")                       # separator is printed to the terminal





def import_solver():
    # importing Kociemba solver
    global sv
    import os.path, pathlib                               # library to check file presence            
    folder = pathlib.Path().resolve()                     # active folder (should be home/pi/cube)  
    fname = os.path.join(folder,'solver2x2x2','solver.py') # active folder + Solver2x2x2 + solver name
    solver_found = False                                  # boolean to track the import the copied solver in subfolder
    if os.path.exists(fname):                             # case the solver exists in 'Solver2x2x2' subfolder
        import solver2x2x2.solver as sv                   # import Kociemba solver copied in sub-folder
        return True                                       # boolean to track the  import the copied solver in subfolder
    else:
        return False                                      # boolean to track the import the copied solver in subfolder





def cube_facelets_permutation(cube_status, move_type, direction):
    """Function that updates the cube status, according to the move type the robot does
       The 'ref' tuples provide the facelet current reference position to be used on the updated position.
       As example, in case of flip, the resulting facelet 0 is the one currently in position 23 (ref[0]).
       The initial cube orientation is not the one the robos has after the scanning process."""
    
    if move_type == 'F':         # case the robot move is a cube flip (complete cube rotation around L-R horizontal axis) 
        ref = (23,22,21,20,5,7,4,6,0,1,2,3,8,9,10,11,18,16,19,17,15,14,13,12) # facelet number corresponding to its index
    
    elif move_type == 'S':       # case the robot move is a spin (complete cube rotation around vertical axis)
        if direction == '1':     # case spin is CW
            ref = (1,3,0,2,8,9,10,11,16,17,18,19,14,12,15,13,20,21,22,23,4,5,6,7) # facelet number corresponding to its index
        elif direction == '3':   # case spin is CCW
            ref = (2,0,3,1,20,21,22,23,4,5,6,7,13,15,12,14,8,9,10,11,16,17,18,19) # facelet number corresponding to its index
    
    elif move_type == 'R':       # case the robot move is a rotation (lowest layer rotation versus mid and top ones) 
        if direction == '1':     # case 1st layer rotation is CW
            ref = (0,1,2,3,4,5,10,11,8,9,18,19,14,12,15,13,16,17,22,23,20,21,6,7) # facelet number corresponding to its index
        elif direction == '3':   # case 1st layer rotation is CCW
            ref = (0,1,2,3,4,5,22,23,8,9,6,7,13,15,12,14,16,17,10,11,20,21,18,19) # facelet number corresponding to its index
    
    new_status = ""              # empty string to generate the cube status, updated according to move_type and direction
    for i in range(24):          # iteration over the 24 facelets
        new_status+=str(cube_status[ref[i]])  # updated cube status takes the facelet from previous status at ref location
    
    return new_status            # updated cube status is returned





def robot_simulator(cube_string):
    """ Calls the Hegbert Kociemba solver, and returns the solution's moves
    from: https://github.com/hkociemba/Rubiks2x2x2-OptimalSolver 
    The solver returns the optimal solution.
    More solutions could be returned, having the same quantity of cube movements; In this case
    it is chosen the faster solution for the robot.
    The cube is virtually manipulated with the movements from the robot solver.
    After the last cube (virtual) manipulation, the resulting cube_status is analyzed.
    Result analysis is thereturn from this function (1=0 ok, 0=Not Ok).
    """
    
    simulation=True                         # flag for the robot solver to run as simulator
    informative=False                       # when informative is set False there are no prints from the optimizers
    solutions = sv.solve(cube_string)       # solver is called to get the solutions (face rotations)
    solutions = solutions.splitlines()      # solver return is plit by lines (more solutions are often returned)
    solutions = [ x.replace(" ","") for x in solutions]  # empty spaces are removed
    
    
    ######################################################################################
    # generating alternative solutions, by also using the D L B faces rotation
    if dbl_enable:                          # case the dbl_enable is set True
        s = solutions.copy()                # solutions list is copied to a shorter variable name                  
        for solution in s:                  # iteration over the solutions returned by the Kociemba solver
            sols = rm.alt_solutions(solution) # alternative solutions are generated
            for sol in sols:                # iteration over the alternative solutions generated
                solutions.append(sol)       # alternative solutions are appended to the original kociemba solutions
        solutions = list(set(solutions))    # duplicated solutions are removed (at the cost of loosing the original order)
    
    if debug:                               # case debug variable is set True
        print()                             # print an empty line
        print(f" Total solutions (solver + alternative for the robot) are: {len(solution)}")  # feedback is printed to the terminal
        print(solution)                     # feedback is printed to the terminal
        print()                             # print an empty line
    # ###################################################################################
    
    additional = 0                          # counter to feedback the quantity of additional solutions analysed
    solution = {}                           # empty dict to store the solver solution(s)
    for i, sol in enumerate(solutions):     # iteration over the returned solutions
        solution[i] = sol[:sol.find('(')]   # sequence of robot manoeuvres are stored per each solver solution

    if len(solution)==1:                    # case there are multiple solutions
        s = solutions[0]                    # the first solution is taken
        solution_Text = s[s.find('(')+1:s.find(')')-1]+' moves  '+ s[:s.find('(')]  # manipulated string, used in Cubotino
        s = s[:s.find('(')]                 # solution capture the sequence of manoeuvres
        if s[:5] =='Error':                 # case solution error (incoherent cube string sent to the solver)
            solution_Text = 'Error'         # 'Error' string is assigned to solution_Text variable
        
        if solution_Text != 'Error':        # case the solver does not returns errors
            
            # string with robot movements, and total movements
            _, robot_moves, total_robot_moves, opt = rm.robot_required_moves(s,solution_Text,simulation,informative)
            est_time = servo.estimate_time(robot_moves, timer, slow_time=0)  # estimation servos time for the single solution
    
    # selecting the solution with lower robot movements
    elif len(solution)>1:                   # case there are multiple solutions
        estimate_time = {}                  # dict to store the solving time taken by the servos
        robot_moves_strings = {}            # dict to store the the robot movement strings
        tot_robot_moves ={}                 # empty dict to store the total robot movements 
        for i, s in solution.items():       # iteration over the solver solutions
            solution_Text = ''              # an empty text is assigned to solution_Text variable  
              
            # string with robot movements, for 'i' solution
            _, robot_moves, total_robot_moves, opt = rm.robot_required_moves(s,solution_Text,simulation,informative)
            estimate_time[i] = servo.estimate_time(robot_moves, timer, slow_time=0)   # estimated time for the robot moves in argument
            robot_moves_strings[i] = robot_moves    # robot movements for the fastest solution
            tot_robot_moves[i] = total_robot_moves  # total quantity of robot movements for the robot moves in argument
        
        additional = i                              # counter for the additional analysed solutions is updated
        best_solution = min(estimate_time, key=estimate_time.get)  # dict index for the fastest solution
        s = solution[best_solution]                 # string of the fastest solver solution 
        est_time = estimate_time[best_solution]     # estimation servos time of the fastest solution
        robot_moves = robot_moves_strings[best_solution]    # robot movements for the fastest solution
        total_robot_moves = tot_robot_moves[best_solution]  # total quantity of robot movements for the fastest solution
            
        # solution_text places the amount of moves first, and the solution (sequence of manoeuvres) afterward
        solution_Text = s[s.find('(')+1:s.find(')')-1]+' moves  '+ s[:s.find('(')] 
        
        ############# forcing failure to test the code  ###################
#         robot_moves = robot_moves+'R1' # forcing a failure to tst the code
        ###################################################################
    
    final_cube_status = robot_virtual_moves(cube_string, robot_moves)
    return solved_status_check(final_cube_status), additional





def robot_virtual_moves(cube_status, robot_moves):
    if len(robot_moves)>0:                        # case there are moves at robot_moves
        for i in range(0, len(robot_moves),2):    # iteration over the robot movements
            move_type = robot_moves[i:i+1]        # robot move type is retrieved from robot_moves string
            direction = robot_moves[i+1:i+2]      # robot move direction/repeats is retrieved from robot_moves string
            if move_type == 'F':                  # case the robot move is F (flip)          
                for i in range(int(direction)):   # iteration over the quantity of flips
                    new_cube_status = cube_facelets_permutation(cube_status, move_type, direction)  # facelets permutation assigned to new_cube_status
                    cube_status = ''              # empty string to generate the cube status, updated according to move_type and direction      
                    for i in range(24):           # iteration over the 24 facelets
                        cube_status+=new_cube_status[i]  # updated cube status takes the facelet from previous status at ref location
            else:                                 # case the robot move is not F (not flip means spin or rotate)
                new_cube_status = cube_facelets_permutation(cube_status, move_type, direction) # facelets permutation assigned to new_cube_status
                cube_status = ''                  # empty string to generate the cube status, updated according to move_type and direction    
                for i in range(24):               # iteration over the 24 facelets
                    cube_status+=new_cube_status[i]  # updated cube status takes the facelet from previous status at ref locatio
        return cube_status                        # updated cube status is returned
    else:                                         # case there are not moves at robot_moves
        return ''                                 # returns an empty string





def solved_status_check(cube_status):
    """Checks is a cube status string is a solved cube.
        The test is performed on 5 faces, that if ok it also means the 6th face is ok.
        Funtion returns 1 for a solved cube, otherwise 0.
    """
    # facelets identification number by face: U R F D L B
    cube = ((0,1,2,3),(4,5,6,7),(8,9,10,11),(12,13,14,15),(16,17,18,19))
    
    if len(cube_status) == 24:  # case the cube status is complete (24 facelets)
        for face in cube:       # iteration over the faces
            for i in range(3):  # iteration over 3 facelets
                
                # case the facelets at location i+1 differs from facelet at location 0 (ref)
                if cube_status[face[i+1]] != cube_status[face[0]]:
                    return 0   # returns zero (means cube is not solved)
        return 1               # returns 1 (means 5 faces are coreect, therefore also the 6th one)





def test_all_permutations(stop_at):
    """Generates all possible permutations of a 2x2x2 Rubik's cube.
    The permutations are generated from the solved cube status: Cube is more scrambled as the simulation proceeds.
    Each permutation (apart the solved cube) is analysed from the Cubotino_P_moves, and the faster one is selected.
    Each set of robot movements is virtually applied.
    After each of the (virtual) cube manipulation, the cube status is updated to reflect the new status.
    The last cube status is analysed if conforming to the solved cube.
    The simulation can be limited to a predefined quantity of tests.
    """
    
    start_time = time.time()                             # time reference is assigned 
    solved_cube = 'UUUURRRRFFFFDDDDLLLLBBBB'             # cube_status of the  solved cube   
    test=0                                               # counter for the tests performed
    test_ok_counter = 0                                  # counter for the cube status correctly solved
    tot_additional = 0                                   # counter for the additional solution tested
    
    dist = [{solved_cube}, set(get_moves(solved_cube))]  # dist holds a list of sets, to track the already tested permutations
    for cube_status in dist[-1]:                         # tests the first 9 permutations applied to the solved cube
        test += 1                                        # test counter is incremented
        ok, additional = robot_simulator(cube_status)    # robot solver simulator is called: positive results and tot alternative are returned
        test_ok_counter += ok                            # test_ok_counter is incremented by 1 
        tot_additional += additional                     # tot_additional is incremented by the additional tested solutions
        if test == 1:
            if dbl_enable:                               # cased dbl_enable is set True
                print("  1) Permutations tested \t 2) Solver & DBL add. solutions \t 3) Robot solver errors")
            else:                                        # cased dbl_enable is set False
                print("  1) Permutations tested \t 2) Solver additional solutions \t 3)Robot solver errors")
            print(" ",test, tot_additional, test-test_ok_counter, end='\r', flush=True)

    while dist[-1]:                                      # looping untill possible to append nes cube statust at dist end
        dist.append(set())                               # and empty set is appended to the dist list
        for pos in dist[-2]:                             # iterating over all the "last added moves"
            for sub_pos in get_moves(pos):               # all the possible moves are applied to each cube status 
                if sub_pos not in dist[-1] and sub_pos not in dist[-2] and sub_pos not in dist[-3]: # case the generated cube status is a new one
                    dist[-1].add(sub_pos)                # new cube status is appended to the set at last dist list position
                    test += 1                            # counter is incremented
                    ok, additional = robot_simulator(sub_pos)  # robot solver simulator is called: positive results and tot analyzed returned
                    test_ok_counter += ok                # counter for test going well is incremented
                    tot_additional += additional         # counter for additional                   
                    print(" ",test, tot_additional, test-test_ok_counter, end='\r', flush=True)
                    if test >= stop_at:                  # case the simulation has reached a predefined target
                        print(" ",test, tot_additional, test-test_ok_counter, "\n")
                        break                            # for loop is interrupted
            if test >= stop_at:                          # case the simulation has reached a predefined target
                break                                    # for loop is interrupted
        if test >= stop_at:                              # case the simulation has reached a predefined target
            break                                        # for loop is interrupted
    
    tot_time = time.time()-start_time                    # total simulation time is calculated
    row = "#"*95+"\n"                                    # string of characters used as separator
    print(row)                                           # separator is printed to the terminal
#     print()                                              # print an empty line
    print(f" Permutations tested: {test:,} ")             # feedback is printed
    if dbl_enable:                                       # cased dbl_enable is set True
        print(f" Additional solution tested (from the solver and robot DBL): {tot_additional:,} ")   # feedback is printed
    else:                                                # cased dbl_enable is set False
        print(f" Additional solution tested (from the solver): {tot_additional:,} ")   # feedback is printed
    print(f" The virtual movements applied by CUBOTino_P have correctly solved {test_ok_counter:,d} different cubes: {round(100*test_ok_counter/test,1)}%")
    print(f" The analysis took {round(tot_time,1)} seconds")
    print(f" (average of {round(1000*tot_time/test,2)} millisecs per each cube status)")
    print()
# ##########################################################################################








############################################################################################
################  test all the 2x2x2 permutations in CUBOTino_P  ###########################
############################################################################################

if __name__ == "__main__":
    
    debug = False
    dbl_enable = True                # flag to enable/disable solutions with DBL faces rotations
    if args.no_dbl != None:          # case 'no_dbl' argument exists
        if args.no_dbl:              # case the script has been launched with 'no_dbl' argument
            dbl_enable = False       # flag to enable/disable the DBL face rotation on cube solutions
    
    stop = False                     # flag to stop the simulation at a givent quantity of permutations
    if args.stop != None:            # case 'stop' argument exists
        stop_at = args.stop          # stop value is assigned
    else:                            # case 'stop' argument exists
        stop_at = 3674160 + 1        # max possible permutations plus one

    clear_terminal()                 # cleares the terminal
    imports()                        # imports the needed libraries
    introduction()                   # prints to terminal the main info about this script

#############################################################################################################
    
    # cube solver to get the solution per each permutation
    ret = import_solver()            # Kociemba solver is imported
    print("Solver imported:", ret)   # feedback is prionted to terminal

    # servos init to get the servos timers, necessary for searching the fastest robot solution
    timer = []                       # empty list to store the timer values
    timer = servo.load_servos_parameters(False)    # servos timers, necessary for searching the fastest robot solution
    if len(timer)>0:                 # case the timer list is not empty
        print("Timers were returned by the robot\n")  # feedback is prionted to terminal
    
    row = "#"*95                     # string of characters used as separator
    print(row)                       # separator is printed to the terminal
    print()

    test_all_permutations(stop_at)   # calls the function that generates all the possible cube permutations
# ##########################################################################################
